import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
const API_URL = 'http://localhost:3000';

describe('CABRILLO Export Endpoints', () => {
  let stationId: string;
  let contestId: string;
  let entryId1: string;

  beforeEach(async () => {
    const timestamp = Date.now();
    // Create test station
    const station = await prisma.station.create({
      data: {
        callsign: `W5CAB${timestamp}`,
        name: 'Test Station',
      },
    });
    stationId = station.id;

    // Create test contest
    const contest = await prisma.contest.create({
      data: {
        name: `ARRL Field Day ${timestamp}`,
      },
    });
    contestId = contest.id;

    // Create test log entries
    const entry1 = await prisma.logEntry.create({
      data: {
        stationId,
        contestId,
        callsign: 'W0XYZ',
        band: '40m',
        mode: 'SSB',
        qsoDate: new Date('2026-01-31'),
        qsoTime: '1500',
        frequency: '7050',
        rstSent: '599',
        rstRcvd: '599',
        operatorCallsign: 'W5ABC',
        source: 'tcp-relay',
        dedupeKey: `cabrillo-1-${timestamp}`,
      },
    });
    entryId1 = entry1.id;

    // Create merged duplicate
    await prisma.logEntry.create({
      data: {
        stationId,
        contestId,
        callsign: 'W0XYZ',
        band: '40m',
        mode: 'SSB',
        qsoDate: new Date('2026-01-31'),
        qsoTime: '1500',
        frequency: '7050',
        rstSent: '599',
        rstRcvd: '599',
        operatorCallsign: 'W5ABC',
        source: 'ui-manual',
        dedupeKey: `cabrillo-1-dup-${Date.now()}`,
        merge_status: 'duplicate_of',
        merged_into_id: entryId1,
        merge_reason: 'duplicate',
        merge_timestamp: new Date(),
      },
    });
  });

  afterEach(async () => {
    // Clean up
    await prisma.logEntry.deleteMany({ where: { contestId } });
    await prisma.contest.deleteMany({ where: { id: contestId } });
    await prisma.station.deleteMany({ where: { id: stationId } });
  });

  describe('GET /api/export/cabrillo', () => {
    it('should export valid CABRILLO format with header', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      expect(response.headers.get('Content-Type')).toMatch(/text\/plain/);
      expect(response.headers.get('Content-Disposition')).toContain('attachment');
      expect(response.headers.get('Content-Disposition')).toContain('.log');

      const content = await response.text();
      expect(content).toContain('START-OF-LOG: 3A');
      expect(content).toContain('END-OF-LOG:');
      expect(content).toContain('END-OF-HEADER:');
    });

    it('should include required CABRILLO header fields', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      // Required header fields
      expect(content).toContain('CALLSIGN:');
      expect(content).toContain('CONTEST:');
      expect(content).toContain('CATEGORY-ASSISTED:');
      expect(content).toContain('CATEGORY-BAND:');
      expect(content).toContain('CATEGORY-MODE:');
      expect(content).toContain('CATEGORY-OPERATOR:');
      expect(content).toContain('CATEGORY-STATION:');
      expect(content).toContain('CATEGORY-POWER:');
    });

    it('should use station callsign in header when stationId provided', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      expect(content).toMatch(/CALLSIGN: W5CAB\d+/);
    });

    it('should include YAHAML soapbox comment', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      expect(content).toContain('SOAPBOX: Generated by YAHAML');
    });

    it('should format QSO lines with required fields', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      // QSO line format: QSO: freq mode date time sent_call sent_rst sent_exch rcvd_call rcvd_rst rcvd_exch
      expect(content).toContain('QSO:');
      expect(content).toContain('W0XYZ');
    });

    it('should exclude merged duplicate entries from export', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      // W0XYZ should appear exactly once (not twice with merged entry)
      const w0xyzMatches = content.match(/W0XYZ/g) || [];
      expect(w0xyzMatches.length).toBeLessThanOrEqual(2); // Max 2: header + one QSO line
    });

    it('should sort QSOs by date then time', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      // Extract QSO lines (after END-OF-HEADER)
      const [, qsoSection] = content.split('END-OF-HEADER:');
      const qsoLines = qsoSection.match(/^QSO:.*/gm) || [];

      // First QSO should be at 1500, second at 1530
      expect(qsoLines.length).toBeGreaterThanOrEqual(1);
      if (qsoLines.length > 1) {
        const firstLine = qsoLines[0];
        const secondLine = qsoLines[1];
        // First should have 1500, second should have 1530
        expect(firstLine).toContain('1500');
        expect(secondLine).toContain('1530');
      }
    });

    it('should return 400 when contestId is missing', async () => {
      const response = await fetch(`${API_URL}/api/export/cabrillo`);

      expect(response.status).toBe(400);
      const error = (await response.json()) as any;
      expect(error.error).toContain('contestId');
    });

    it('should return 404 when contest does not exist', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=nonexistent&stationId=${stationId}`
      );

      expect(response.status).toBe(404);
      const error = (await response.json()) as any;
      expect(error.error).toContain('Contest not found');
    });

    it('should validate callsign in entries', async () => {
      // Create entry with missing callsign (if schema allows)
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200); // Should still export with validation
    });

    it('should include location in header when provided', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}&location=Texas`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      expect(content).toContain('LOCATION: Texas');
    });

    it('should default callsign to UNKNOWN if stationId not provided', async () => {
      const response = await fetch(`${API_URL}/api/export/cabrillo?contestId=${contestId}`);

      expect(response.status).toBe(200);
      const content = await response.text();

      expect(content).toContain('CALLSIGN: UNKNOWN');
    });

    it('should use contest name in header', async () => {
      const response = await fetch(
        `${API_URL}/api/export/cabrillo?contestId=${contestId}&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      expect(content).toMatch(/CONTEST: ARRL Field Day \d+/);
    });
  });
});

describe('Reverse-Log Export Endpoints', () => {
  let stationId: string;
  let contestId: string;
  let localEntryId: string;

  beforeEach(async () => {
    const timestamp = Date.now();
    // Create test station
    const station = await prisma.station.create({
      data: {
        callsign: `W5REV${timestamp}`,
        name: 'Test Station',
      },
    });
    stationId = station.id;

    // Create test contest
    const contest = await prisma.contest.create({
      data: {
        name: `Test Contest for Reverse Log ${timestamp}`,
      },
    });
    contestId = contest.id;

    // Create entry: W5TEST heard W0XYZ
    const localEntry = await prisma.logEntry.create({
      data: {
        stationId,
        contestId,
        callsign: 'W0XYZ',
        band: '40m',
        mode: 'SSB',
        qsoDate: new Date('2026-01-31'),
        qsoTime: '1500',
        frequency: '7050',
        rstSent: '599',
        rstRcvd: '599',
        operatorCallsign: 'W5ABC',
        source: 'tcp-relay',
        dedupeKey: `reverse-1-${timestamp}`,
      },
    });
    localEntryId = localEntry.id;

    // Create entry: W5TEST heard W5ABC (different operator)
    await prisma.logEntry.create({
      data: {
        stationId,
        contestId,
        callsign: 'W5ABC',
        band: '20m',
        mode: 'CW',
        qsoDate: new Date('2026-01-31'),
        qsoTime: '1530',
        frequency: '14200',
        rstSent: '559',
        rstRcvd: '559',
        operatorCallsign: 'W5DEF',
        source: 'wsjt-x',
        dedupeKey: `reverse-2-${timestamp}`,
      },
    });
  });

  afterEach(async () => {
    // Clean up
    await prisma.logEntry.deleteMany({ where: { contestId } });
    await prisma.contest.deleteMany({ where: { id: contestId } });
    await prisma.station.deleteMany({ where: { id: stationId } });
  });

  describe('GET /api/export/reverse-log', () => {
    it('should export reverse-log in CABRILLO format', async () => {
      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=W0XYZ&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      expect(response.headers.get('Content-Type')).toMatch(/text\/plain/);
      expect(response.headers.get('Content-Disposition')).toContain('attachment');
      expect(response.headers.get('Content-Disposition')).toContain('reverse-log');

      const content = await response.text();
      expect(content).toContain('START-OF-LOG: 3A');
      expect(content).toContain('END-OF-LOG:');
    });

    it('should include only QSOs with specified remote callsign', async () => {
      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=W0XYZ&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      // Should include W0XYZ in log
      expect(content).toContain('Reverse-Log for W0XYZ');
      // Should have exactly 1 QSO with W0XYZ
      const w0xyzMatches = content.match(/W0XYZ/g) || [];
      expect(w0xyzMatches.length).toBeGreaterThanOrEqual(1);
    });

    it('should use local station callsign when provided', async () => {
      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=W0XYZ&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      expect(content).toMatch(/CALLSIGN: W5REV\d+/);
    });

    it('should return 400 when contestId is missing', async () => {
      const response = await fetch(`${API_URL}/api/export/reverse-log?remote_call=W0XYZ`);

      expect(response.status).toBe(400);
      const error = (await response.json()) as any;
      expect(error.error).toContain('contestId');
    });

    it('should return 400 when remote_call is missing', async () => {
      const response = await fetch(`${API_URL}/api/export/reverse-log?contestId=${contestId}`);

      expect(response.status).toBe(400);
      const error = (await response.json()) as any;
      expect(error.error).toContain('remote_call');
    });

    it('should return 404 when contest does not exist', async () => {
      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=nonexistent&remote_call=W0XYZ`
      );

      expect(response.status).toBe(404);
      const error = (await response.json()) as any;
      expect(error.error).toContain('Contest not found');
    });

    it('should return 404 when no QSOs with remote_call exist', async () => {
      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=NONEXISTENT`
      );

      expect(response.status).toBe(404);
      const error = (await response.json()) as any;
      expect(error.error).toContain('No QSO entries found');
    });

    it('should exclude merged duplicate entries', async () => {
      // Create a duplicate of the W0XYZ entry
      await prisma.logEntry.create({
        data: {
          stationId,
          contestId,
          callsign: 'W0XYZ',
          band: '40m',
          mode: 'SSB',
          qsoDate: new Date('2026-01-31'),
          qsoTime: '1500',
          frequency: '7050',
          rstSent: '599',
          rstRcvd: '599',
          operatorCallsign: 'W5ABC',
          source: 'ui-manual',
          dedupeKey: 'reverse-duplicate',
          merge_status: 'duplicate_of',
          merged_into_id: localEntryId,
          merge_reason: 'duplicate',
          merge_timestamp: new Date(),
        },
      });

      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=W0XYZ&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      // Should still have W0XYZ but only once
      const qsoLines = content.match(/^QSO:.*/gm) || [];
      expect(qsoLines.length).toBe(1);
    });

    it('should include location when provided', async () => {
      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=W0XYZ&stationId=${stationId}&location=Kansas`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      expect(content).toContain('LOCATION: Kansas');
    });

    it('should sort QSOs by date and time', async () => {
      // Add another QSO with W0XYZ at different time
      await prisma.logEntry.create({
        data: {
          stationId,
          contestId,
          callsign: 'W0XYZ',
          band: '20m',
          mode: 'CW',
          qsoDate: new Date('2026-01-31'),
          qsoTime: '2000',
          frequency: '14200',
          rstSent: '599',
          rstRcvd: '599',
          operatorCallsign: 'W5ABC',
          source: 'tcp-relay',
          dedupeKey: 'reverse-3',
        },
      });

      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=W0XYZ&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      // Extract QSO lines
      const qsoLines = content.match(/^QSO:.*/gm) || [];
      expect(qsoLines.length).toBe(2);
      // Should be sorted by time: 1500 before 2000
      expect(qsoLines[0]).toContain('1500');
      expect(qsoLines[1]).toContain('2000');
    });

    it('should default callsign to UNKNOWN if stationId not provided', async () => {
      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=W0XYZ`
      );

      expect(response.status).toBe(200);
      const content = await response.text();

      expect(content).toContain('CALLSIGN: UNKNOWN');
    });

    it('should generate proper filename with remote callsign', async () => {
      const response = await fetch(
        `${API_URL}/api/export/reverse-log?contestId=${contestId}&remote_call=W0XYZ&stationId=${stationId}`
      );

      expect(response.status).toBe(200);
      const disposition = response.headers.get('Content-Disposition') || '';

      expect(disposition).toContain('reverse-log');
      expect(disposition).toContain('W0XYZ');
    });
  });
});
