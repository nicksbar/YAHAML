import { LogEntry } from '@prisma/client';

/**
 * ADIF-3 Export Module
 * Converts QSO log entries to ADIF format (eQSL/LoTW compatible)
 */

interface AdifField {
  field: string;
  value: string | number;
}

/**
 * Normalize band format to ADIF standard (e.g., "40m" → "40M", "160" → "160M")
 */
export function normalizeBand(band: string | null | undefined): string {
  if (!band) return '';
  
  const normalized = band
    .toUpperCase()
    .replace(/M$/, 'M') // Already has M
    .replace(/^(\d+)$/, '$1M'); // Add M if missing
  
  // Validate against ADIF band list
  const validBands = ['160M', '80M', '60M', '40M', '30M', '20M', '17M', '15M', '12M', '10M', 
                      '6M', '2M', '70CM', '33CM', '23CM', '13CM', '9CM', '5CM', '3CM', '1.2CM', 'SUBMM'];
  
  return validBands.includes(normalized) ? normalized : band.toUpperCase();
}

/**
 * Format date for ADIF (YYYYMMDD)
 */
export function formatAdifDate(date: Date | null | undefined): string {
  if (!date) return '';
  const d = new Date(date);
  const year = d.getUTCFullYear();
  const month = String(d.getUTCMonth() + 1).padStart(2, '0');
  const day = String(d.getUTCDate()).padStart(2, '0');
  return `${year}${month}${day}`;
}

/**
 * Format time for ADIF (HHMMSS)
 */
export function formatAdifTime(time: string | null | undefined): string {
  if (!time) return '';
  // Assume time is already in HHmm or HHMM format, pad to HHMMSS
  return String(time).padEnd(6, '0').slice(0, 6);
}

/**
 * Build individual ADIF record from LogEntry
 */
export function buildAdifRecord(entry: LogEntry, _format: '2' | '3' = '3'): AdifField[] {
  const fields: AdifField[] = [
    // Mandatory fields (eQSL minimum)
    { field: 'QSO_DATE', value: formatAdifDate(entry.qsoDate) },
    { field: 'TIME_ON', value: formatAdifTime(entry.qsoTime) },
    { field: 'CALL', value: entry.callsign },
    { field: 'MODE', value: entry.mode },
    { field: 'BAND', value: normalizeBand(entry.band) },
    
    // Recommended fields
    ...(entry.frequency ? [{ field: 'FREQ', value: entry.frequency }] : []),
    ...(entry.rstSent ? [{ field: 'RST_SENT', value: entry.rstSent }] : []),
    ...(entry.rstRcvd ? [{ field: 'RST_RCVD', value: entry.rstRcvd }] : []),
    ...(entry.operatorCallsign ? [{ field: 'OPERATOR', value: entry.operatorCallsign }] : []),
    { field: 'STATION_CALLSIGN', value: entry.stationId },
    
    // YAHAML extensions
    ...(entry.contestId ? [{ field: 'CONTEST_ID', value: entry.contestId }] : []),
    { field: 'SOURCE', value: entry.source || 'unknown' },
  ];
  
  // ADIF 3.1 additional fields would go here
  // Filter out empty values
  return fields.filter(f => f.value !== '' && f.value !== null && f.value !== undefined);
}

/**
 * Format single ADIF field: <FIELDNAME:LENGTH>VALUE
 * Example: <QSO_DATE:8>20260131
 */
export function formatAdifField(field: AdifField): string {
  const valueStr = String(field.value);
  const len = valueStr.length;
  return `<${field.field}:${len}>${valueStr}`;
}

/**
 * Convert array of ADIF fields to ADIF record string
 */
export function formatAdifRecord(fields: AdifField[]): string {
  return fields.map(formatAdifField).join('') + '<EOR>\n';
}

/**
 * Generate complete ADIF file content
 */
export function generateAdifContent(entries: LogEntry[], format: '2' | '3' = '3'): string {
  // Header
  const header = `ADIF_VER:5|3.1.0|PROGRAMID:6|YAHAML|FILE_TYPE:3|LOG|EOH\n`;
  
  // Records
  const records = entries
    .map(entry => buildAdifRecord(entry, format))
    .map(fields => formatAdifRecord(fields))
    .join('');
  
  return header + records;
}

/**
 * CABRILLO Export Module
 * Converts QSO log entries to CABRILLO format (contest submission)
 */

interface CabrilloQso {
  frequency: string;
  mode: string;
  date: string;
  time: string;
  sentCall: string;
  sentRst: string;
  sentExchange: string;
  rcvdCall: string;
  rcvdRst: string;
  rcvdExchange: string;
  power?: string;
}

/**
 * Generate CABRILLO header
 */
export function generateCabrilloHeader(
  callsign: string,
  contestName: string,
  category: string = 'SINGLE-OP',
  location: string = ''
): string {
  return `START-OF-LOG: 3A
CALLSIGN: ${callsign}
CONTEST: ${contestName}
CATEGORY-ASSISTED: NON-ASSISTED
CATEGORY-BAND: ALL
CATEGORY-MODE: MIXED
CATEGORY-OPERATOR: ${category}
CATEGORY-STATION: FIXED
CATEGORY-POWER: LOW
${location ? `LOCATION: ${location}\n` : ''}SOAPBOX: Generated by YAHAML contest logger
END-OF-HEADER:
`;
}

/**
 * Format QSO line for CABRILLO (standard format)
 * QSO: freq mode date time sent_call sent_rst sent_exch rcvd_call rcvd_rst rcvd_exch
 */
export function formatCabrilloQso(qso: CabrilloQso): string {
  const line = `QSO: ${qso.frequency.padEnd(5)} ${qso.mode.padEnd(2)} ${qso.date} ${qso.time} ${qso.sentCall.padEnd(13)} ${qso.sentRst.padEnd(3)} ${qso.sentExchange.padEnd(12)} ${qso.rcvdCall.padEnd(13)} ${qso.rcvdRst.padEnd(3)} ${qso.rcvdExchange}`;
  return line + (qso.power ? ` TX:${qso.power}` : '') + '\n';
}

/**
 * Generate complete CABRILLO file content
 */
export function generateCabrilloContent(
  entries: LogEntry[],
  callsign: string,
  contestName: string,
  location?: string
): string {
  const header = generateCabrilloHeader(callsign, contestName, 'SINGLE-OP', location);
  
  const qsos = entries
    .sort((a, b) => {
      const dateA = new Date(a.qsoDate).getTime();
      const dateB = new Date(b.qsoDate).getTime();
      if (dateA !== dateB) return dateA - dateB;
      return (a.qsoTime || '').localeCompare(b.qsoTime || '');
    })
    .map(entry => {
      const qso: CabrilloQso = {
        frequency: entry.frequency ? `${entry.frequency}` : '7025',
        mode: entry.mode || 'SSB',
        date: formatAdifDate(entry.qsoDate),
        time: formatAdifTime(entry.qsoTime),
        sentCall: entry.stationId || 'UNKNOWN',
        sentRst: entry.rstSent || '599',
        sentExchange: '1',
        rcvdCall: entry.callsign,
        rcvdRst: entry.rstRcvd || '599',
        rcvdExchange: '1',
      };
      return formatCabrilloQso(qso);
    })
    .join('');
  
  return header + qsos + 'END-OF-LOG:\n';
}

/**
 * Validate CABRILLO QSO line format
 */
export function validateCabrilloQso(entry: LogEntry): string[] {
  const errors: string[] = [];
  
  if (!entry.callsign) errors.push('Missing callsign');
  if (!entry.mode) errors.push('Missing mode');
  if (!entry.qsoDate) errors.push('Missing QSO date');
  if (!entry.qsoTime) errors.push('Missing QSO time');
  
  // Validate mode
  const validModes = ['CW', 'SSB', 'AM', 'FM', 'RTTY', 'FT8', 'FT4', 'JS8'];
  if (entry.mode && !validModes.includes(entry.mode.toUpperCase())) {
    errors.push(`Invalid mode: ${entry.mode}`);
  }
  
  // Validate band
  if (entry.band) {
    const validBands = ['160', '80', '60', '40', '30', '20', '17', '15', '12', '10', '6', '2', '70CM', '33CM', '23CM'];
    const bandMatch = validBands.find(b => entry.band?.includes(b));
    if (!bandMatch) {
      errors.push(`Invalid band: ${entry.band}`);
    }
  }
  
  return errors;
}
